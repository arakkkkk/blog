[{"content":"DockerでローカルLLMを始める（Ollama + Open WebUI） ローカルでLLMを試すための最小構成をDocker Composeで用意しました。ブラウザ（Open WebUI）からの利用と、OllamaのAPIの基本的な呼び出し方を簡単にまとめています。\n対象リポジトリ: practice-llm-mcp（Composeと初期化スクリプトを同梱）\nクイックスタート 前提条件\nDocker と Docker Compose が導入済み 初回のみモデルのダウンロードが発生（ネットワーク接続が必要） リポジトリ取得 1 2 git clone https://github.com/arakkkkk/practice-llm-mcp.git cd practice-llm-mcp コンテナ起動 1 2 3 4 # 環境によっては sudo が必要です sudo docker compose up -d # Makefile を使う場合 make run 動作確認（ブラウザ / API） ブラウザ: http://localhost:8080 へアクセス API: curl で確認 1 2 3 4 5 curl http://localhost:11434/api/generate -d \u0026#39;{ \u0026#34;model\u0026#34;: \u0026#34;qwen:7b-chat\u0026#34;, \u0026#34;prompt\u0026#34;: \u0026#34;明日のやることを3つ箇条書きで\u0026#34;, \u0026#34;stream\u0026#34;: false }\u0026#39; 停止する場合:\n1 2 3 sudo docker compose down # または make down コンポーネント概要（Ollama / Open WebUI） Ollama 役割: ローカルでLLMモデルを実行するエンジン（HTTP 11434 でAPI提供） 取得: ollama pull \u0026lt;model\u0026gt; でモデルをダウンロード 保存: 本構成では ./ollama/data に永続化 Open WebUI 役割: ブラウザからOllamaを利用するためのUI 接続: OLLAMA_BASE_URL で Ollama に接続（Composeでは http://ollama:11434） アクセス: http://localhost:8080 保存: 会話履歴等は ./webui/data に保存 構成のポイント 1) docker compose compose.yml では以下の2サービスを定義しています。\nollama\nポート 11434 を公開（API） モデルを ./ollama/data に永続化 起動後の初期化でモデルを準備（init.sh） open-webui\nポート 8080 でWeb UIを提供 OLLAMA_BASE_URL=http://ollama:11434 depends_on: [ollama] 2) Ollamaの初期化 ollama/init.sh で、Ollamaの待ち受け開始を確認した後にモデルをまとめて取得します（初回のみ時間がかかります）。取得対象の例：\nphi3:mini llama3:8b qwen:7b-chat mistral 埋め込み用途: gte-small, e5-small-v2, nomic-embed-text 不要なモデルがある場合は、init.sh の ollama pull 行を調整してください。 利用可能なモデルはlibraryを参考にしてください。\n3) Makefile 基本操作のショートカットです。\nmake run … 起動（docker compose up -d） make down … 停止 make logs … ログ確認 make restart … 再ビルド＋再起動 補足メモ ポート\n11434: Ollama HTTP API（/api/chat と /api/generate） 8080: Open WebUI 永続化\nモデルは容量が大きいため、./ollama/data に保存して再ダウンロードを避けます WebUI のデータは ./webui/data に保存します 起動順制御\ndepends_on に加えて init.sh で疎通確認を行います モデル選定\nまずは軽量な phi3:mini で確認 → qwen:7b-chat や llama3:8b へ拡張 よくあるハマりどころ 初回起動が長い\nモデルのダウンロード時間がかかります。make logs で進捗を確認してください ポート競合\ncompose.yml のポートマッピング（例: 11434:11434）の左側を空いている番号に変更します WebUIは開けるが応答がない\nopen-webui の OLLAMA_BASE_URL が http://ollama:11434 か、ollama コンテナが起動しているかを確認します 権限エラー\nsudo を付けるか、ユーザーを docker グループへ追加します まとめ 以下の手順でローカルLLM環境を用意できます。\ndocker compose up -d（または make run） ブラウザは http://localhost:8080、API は http://localhost:11434 必要に応じて取得するモデルやポート番号を調整しながら、用途に合わせて拡張してください。\n","date":"2025-11-07T00:00:00Z","permalink":"http://192.168.122.81/p/docker%E3%81%A7%E3%82%B5%E3%82%AF%E3%83%83%E3%81%A8%E5%A7%8B%E3%82%81%E3%82%8B%E3%83%AD%E3%83%BC%E3%82%AB%E3%83%ABllmollama--open-webui/","title":"Dockerでサクッと始めるローカルLLM(Ollama + Open WebUI)"},{"content":"Codexとは OpenAI主導のオープンソース「Codex」のブラウザUIは、PCに特別なセットアップを行わずに、Webブラウザだけで「AIと一緒に開発」を実現するクラウドIDEです。ポイントは次の3つです。\nAIがコードの読み解きと変更案の提案を行い、差分パッチとして提示する リポジトリ（ブランチ）を指定して安全に作業し、必要に応じて複数案を比較検討できる 会話（プロンプト）と計画（/plan 等）を軸に、設計→実装→検証→リファクタまでを一貫支援する このエントリでは、ブラウザ版Codexの全体像、実務での使い方、プロンプト設計の勘所、CLI版との使い分け、そして失敗しにくいワークフローをまとめます。\n※CLIやIDEからも使えます\nブラウザ版Codexでできること 日々の開発作業を“会話で駆動”するのが特徴です。代表的な機能と具体的な活用イメージを挙げます。\n設計レビューと要件すり合わせ 既存コードやREADMEを読み取り、ゴール・制約・テスト観点を要約。 コード生成と安全な編集 計画駆動の実装（/plan） 作業を小さなステップに分解し、進捗に応じて更新。途中での方針転換も明瞭です（後述）。 リファクタ提案とドキュメント更新 命名、分割、責務の明確化を提案。変更に伴うREADMEやコメントの追随も依頼可能。 トラブルシューティング支援 エラーログを貼ると原因仮説→切り分け手順→修正案までを段階的に提示。 ブラウザで利用できるのでスマホでも手軽に利用できる。電車やお風呂でも開発ができます。\nまずは触ってみる Codexへアクセスし、対象の repository と作業する branch を選択。 必要に応じて「バージョン（複数案）」を有効化。比較レビューがしやすくなります。 最初のプロンプトでゴールと制約を明確化（例は後述）。 変更提案は必ず差分を確認してから反映。大きい差分は/planで段階化。 反映後はテスト・ビルド・静的解析など、既存の検証手段で確認します。 補助コマンドの例：\n/plan 作業計画の作成・更新。ステップを短く保つと失敗に強い。 （運用ルール）「1トピック＝1PR」を徹底。大規模変更はサブタスクに分割。 実践ミニチュートリアル：安全な小さな変更を積む ここでは、例として私が開発しているNeovimプラグインをリファクタしてもらいます\nプロンプト作成 かなり雑ではありますが、お試しということで以下で試行してみます プロンプト 1 2 3 4 このプロジェクトのLuaコードをリファクタしてください。 ・冗長なコードや重複ロジックを整理 ・変数名が分かりにくい場合は、より意味のある名前に変更 ・関数や機能の動作は一切変更しない repository: arakkkkk/kanban.nvim branch: main version: 2つ（2パターンの提案を出してくれます） 実行 プロンプトの入力が完了したら、実行ボタンから実行します\n結果表示\nプロンプト下のタスクタブに結果が一覧されるので、そこから結果を表示します。 差分をレビューして反映 結果は以下のように表示されます。 さらに、左サイドバーのチャット欄から追加で指示をすることも可能です。\n差分の粒度が大きい場合は「ステップ2と3を分けて提案して」とリクエスト。 命名やエラーメッセージは「既存に合わせる/揃えて」と再指示。 UIの表記は環境により異なる場合があります。\nPRを作成 画面左上の「PRを作成する」ボタンからGitHubのPull Requestを作成できます。 エディター/CLIを使わない開発は少し寂しいですが\u0026hellip;開発はだいぶ楽になりそうです。\n/plan機能 Codexでは、プロンプトで/planというコマンドが利用可能です。 これはコード変更の計画（PLAN）を生成するための専用モード／コマンドです。 と言ってもよくわからないので例を紹介します。\n例えば、以下プロンプトで修正提案をしてみます。\n1 2 3 /plan 冗長なコードをリファクタし、変数名を分かりやすく改善したい。 動作は変えずにコードの可読性を向上させる。 しかし、このような指示の方法だと複数の関数をまとめて修正されてレビューが大変になります。(AIコーディングあるあるだと思います) /planコマンドでは、これを解決できます！\n実際に実行した結果は以下のようになります。 このように、/planを使うことで修正を分割してタスクとして表示してくれます。あとは対象のタスクを選んで「タスクを開始」をクリックすることで個々の変更を適用できます。 少々時間がかかりますが、完了するとボタンが「タスクを表示する」に変わるので、クリックして変更内容を確認します。 以降のPR作成までの手順は通常と同じです。/planで提示された変更ごとにPRを作成することができます。\n成果が変わるプロンプト設計 短い指示ほど強いですが、前提は十分に与えます。私がよく使う型を紹介します。\nゴール宣言型 「目的」「制約」「評価基準」「出力形式」を1ブロックで明示。 境界指定型 触ってよいファイル範囲、禁止事項（公開API変更・破壊的変更・不要リネーム等）。 比較検討型 2〜3案を出させ、採用理由・トレードオフを簡潔に。差分は最小の案を優先。 漸進型 大改修は“段取り”に分ける。「まず型だけ」「次に実装」「最後に最適化」。 品質と安全性を高めるワークフロー 小さく始めて小さくマージ 1PRの変更を「1目的」に限定。ロールバック容易性を常に意識。 既存の検証手段を尊重 Linter/Formatter/Tests/Build を会話の外で必ず実行して裏取り。 差分は“理由”付き 変更には必ず動機を書く。将来の自分と同僚へのドキュメント。 計画の継続更新 /plan を最新に保ち、途中の軌道修正を見える化。 よくあるつまずきと対処 出力が過剰・空回りする 「差分は最小」「既存スタイルを踏襲」「不要なリネーム禁止」を明言。 複数ファイルに跨る影響が読めない まず影響調査だけを依頼→次に小さな変更1つ、の順で段階化。 大規模リファクタが一気に来る “段取り化”を要求し、各段の終了基準（テスト・ビルド）を明示。 曖昧な要求で期待外れ 目的・制約・評価基準・出力形式の4点セットに立ち返る。 CLI版との使い分け ブラウザ版 手早い設計議論、差分レビュー、複数案の比較に最適。 スマホでも手軽に利用できる。移動中など短時間でもレビューや指示が可能（音声入力も可能）。 CLI版 ローカルのテスト実行や既存ツール連携をフル活用。自動化パイプラインにも載せやすい。 ","date":"2025-11-03T00:00:00Z","permalink":"http://192.168.122.81/p/%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E7%89%88codex%E3%81%A7%E5%A7%8B%E3%82%81%E3%82%8B%E3%82%AF%E3%83%A9%E3%82%A6%E3%83%89%E9%96%8B%E7%99%BA%E5%85%A5%E9%96%80/","title":"ブラウザ版Codexで始めるクラウド開発入門"},{"content":"踏み台サーバー経由でAnsibleを実行する方法について、少し詰まったので備忘録\n結論 踏み台サーバーを使った多段SSHの設定として以下のパラメータを設定することで可能となります\n1 ansible_ssh_common_args: \u0026#39;-o ProxyCommand=\u0026#34;ssh -i {{ bastion_ssh_private_key_file }} -p {{ bastion_port }} {{ bastion_user }}@{{ bastion_host }} -W %h:%p\u0026#34;\u0026#39; サンプル: arakkkkk/example-ansible-proxyjump\n構成 以下の構成で、対象サーバーへ踏み台サーバー経由でAnsibleを実行します。\n\u0026lt;!-- A[ローカルマシン\u0026lt;br/\u0026gt;Ansible実行サーバー] --\u0026gt;|SSH:2222\u0026lt;br\u0026gt;公開鍵認証| B[踏み台サーバー\u0026lt;br/\u0026gt;192.168.11.10] --\u0026gt; \u0026lt;!-- B --\u0026gt;|SSH:2222\u0026lt;br\u0026gt;公開鍵認証/パスワード認証| C[対象サーバー\u0026lt;br/\u0026gt;192.168.122.70] --\u0026gt; 前提条件 踏み台サーバーと対象サーバーの両方でSSH公開鍵認証が設定済み 両サーバーともSSHポート2222で接続 hosts設定 (踏み台サーバー/対象サーバー共に公開鍵認証) hostsファイルに以下の設定を記述\n1 ansible-client ansible_host=192.168.122.70 ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/keys/id_ed25519 ansible_ssh_common_args=\u0026#39;-o ProxyCommand=\u0026#34;ssh -i ~/.ssh/keys/id_ed25519 -p 2222 ubuntu@192.168.11.10 -W %h:%p\u0026#34;\u0026#39; ansible_port=2222 ansible-client.ymlのようにhost_varsのymlに記載すると管理しやすいかと思います\nansible_host: 対象サーバーのIPアドレス ansible_user: 対象サーバーのSSH接続ユーザー ansible_ssh_private_key_file: 秘密鍵ファイルのパス ansible_port: 対象サーバーのSSHポート ansible_ssh_common_args: SSH接続時の追加オプション (踏み台へのSSH接続情報) ProxyCommand: 踏み台サーバー経由での接続コマンド -W %h:%p: ポートフォワーディング設定 hosts設定 (踏み台サーバーは公開鍵認証、対象サーバーはパスワード認証) 踏み台サーバーには証明書認証、対象サーバーにはパスワード認証という場合でもAnsibleによる実行は可能です。\nansible_ssh_private_key_fileパラメータを削除し、実行時に--ask-passをつけて実行時にパスワードを入力して実行が可能です。\n1 ansible-client ansible_host=192.168.122.70 ansible_user=ubuntu ansible_ssh_common_args=\u0026#39;-o ProxyCommand=\u0026#34;ssh -i ~/.ssh/keys/id_ed25519 -p 2222 ubuntu@192.168.11.10 -W %h:%p\u0026#34;\u0026#39; ansible_port=2222 Ansible Vault等でパスワードを保存している場合、ansible_ssh_passパラメータとして用意しておくことも可能です\n1 ansible-client ansible_host=192.168.122.70 ansible_user=ubuntu ansible_ssh_common_args=\u0026#39;-o ProxyCommand=\u0026#34;ssh -i ~/.ssh/keys/id_ed25519 -p 2222 ubuntu@192.168.11.10 -W %h:%p\u0026#34;\u0026#39; ansible_ssh_pass={{ vault_bastion_pass }} ansible_port=2222 ※ただし、上記方式での実行にはsshpassのインストールが必要です\n","date":"2025-07-25T00:00:00Z","permalink":"http://192.168.122.81/p/%E8%B8%8F%E3%81%BF%E5%8F%B0%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E7%B5%8C%E7%94%B1%E3%81%A7%E3%81%AEansible%E5%AE%9F%E8%A1%8C/","title":"踏み台サーバー経由でのAnsible実行"},{"content":"Neovimでcodecompanionを使いたい人向けのガイド(2025/7/5時点) 前回はCopilot今回は\nNeovimのAvanteプラグインでできること 補完機能 利用している補完用プラグインとの連携も可能です。 チャットモード Avanteでは、コードの質問のみ行う:AvanteAskと、編集を同時に行える:AvanteChatのコマンドが用意されています。 :AvanteChatでは、チャットをしながらコードの変更が可能です。CopilotChatのAgentモード相当の機能を有しており、複数ファイルの編集や、ファイル作成も行ってくれます。\nまた、コードの差分も見やすく表示されるので使い勝手は非常に良いです。\n部分的に編集したければ、:AvanteEditを以下画像のように利用することも可能です。 また、mcphub.nvimを利用することでMCPも利用可能です。こちらはまだ試せていないので、別記事にて紹介しようと思います。 https://ravitemer.github.io/mcphub.nvim/extensions/avante.html\n設定方法 ここでは lazy.nvim を使った設定方法を記載しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;yetone/avante.nvim\u0026#34;, build = function() -- conditionally use the correct build system for the current OS if vim.fn.has(\u0026#34;win32\u0026#34;) == 1 then return \u0026#34;powershell -ExecutionPolicy Bypass -File Build.ps1 -BuildFromSource false\u0026#34; else return \u0026#34;make\u0026#34; end end, dependencies = { \u0026#34;nvim-treesitter/nvim-treesitter\u0026#34;, \u0026#34;stevearc/dressing.nvim\u0026#34;, \u0026#34;nvim-lua/plenary.nvim\u0026#34;, \u0026#34;MunifTanjim/nui.nvim\u0026#34;, }, ops = { ---@alias Provider \u0026#34;claude\u0026#34; | \u0026#34;openai\u0026#34; | \u0026#34;azure\u0026#34; | \u0026#34;gemini\u0026#34; | \u0026#34;cohere\u0026#34; | \u0026#34;copilot\u0026#34; | string provider = \u0026#34;copilot\u0026#34;, } }, Avanteで使えるプロンプトの接頭辞 Avanteでは、@mentionsを使うことでプロンプトに情報を追加することができます\nMention 説明 @codebase プロジェクト全体のソースコード @diagnostics diagnosticの情報 @file 特定のファイル @quickfix quickfix @buffers buffers @codebaseと@fileがよく使うメンションになるかと思います。また、@fileについては以下画像のようにファイルの検索が可能で便利です。 まとめ Copilot.luaと比較すると機能がかなり豊富になっていることがわかったかと思います。 チャットモードによるファイル編集・ファイル作成、部分的な編集ができるとともに、MCPも利用することができるのでこのプラグインを上手に活用できればVS Codeに劣らずAIを用いたコーディングができるプラグインになっているかと思います。 但し、難点としてチャットの回答が体感遅いのでこちらは我慢が必要です。(もしくは、copilotで試していたので他のモデルを利用することで改善するかもしれません。)\n","date":"2025-07-08T00:00:00Z","permalink":"http://192.168.122.81/p/neovim%E3%81%A7ai%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0-codecompanion%E7%B7%A8/","title":"NeovimでAIコーディング (codecompanion編)"},{"content":"NeovimでAvanteを使いたい人向けのガイド(2025/7/5時点) 前回はCopilot.luaについて書いたので、今回はAvanteについて紹介してみます。\nNeovimのAvanteプラグインでできること チャットモード Avanteでは、コードの質問のみ行う:AvanteAskと、編集を同時に行える:AvanteChatのコマンドが用意されています。\n:AvanteChatでは、チャットをしながらコードの変更が可能です。CopilotChatのAgentモード相当の機能を有しており、複数ファイルの編集や、ファイル作成も行ってくれます。\nまた、コードの差分も見やすく表示されるので使い勝手は非常に良いです。 部分的に編集したければ、:AvanteEditを以下画像のように利用することも可能です。 また、mcphub.nvimを利用することでMCPも利用可能です。こちらはまだ試せていないので、別記事にて紹介しようと思います。 https://ravitemer.github.io/mcphub.nvim/extensions/avante.html\n設定方法 ここでは lazy.nvim を使った設定方法を記載しています。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;yetone/avante.nvim\u0026#34;, build = function() -- conditionally use the correct build system for the current OS if vim.fn.has(\u0026#34;win32\u0026#34;) == 1 then return \u0026#34;powershell -ExecutionPolicy Bypass -File Build.ps1 -BuildFromSource false\u0026#34; else return \u0026#34;make\u0026#34; end end, dependencies = { \u0026#34;nvim-treesitter/nvim-treesitter\u0026#34;, \u0026#34;stevearc/dressing.nvim\u0026#34;, \u0026#34;nvim-lua/plenary.nvim\u0026#34;, \u0026#34;MunifTanjim/nui.nvim\u0026#34;, }, ops = { ---@alias Provider \u0026#34;claude\u0026#34; | \u0026#34;openai\u0026#34; | \u0026#34;azure\u0026#34; | \u0026#34;gemini\u0026#34; | \u0026#34;cohere\u0026#34; | \u0026#34;copilot\u0026#34; | string provider = \u0026#34;copilot\u0026#34;, } }, Avanteで使えるプロンプトの接頭辞 @mentions @mentionsを使うことでプロンプトに情報を追加することができます\nMention 説明 @codebase プロジェクト全体のソースコード @diagnostics diagnosticの情報 @file 特定のファイル @quickfix quickfix @buffers buffers @codebaseと@fileがよく使うメンションになるかと思います。また、@fileについては以下画像のようにファイルの検索が可能で便利です。 / スラッシュコマンドを使うことで特定の機能を呼び出すことができます\nMention 説明 /help ヘルプを表示します /lines 特定の行について質問します（例: /lines - \u0026lt;質問\u0026gt;） /new 新しいチャットを開始します /init 現在のプロジェクトに基づいてAGENTS.mdを初期化します /clear チャット履歴をクリアします /commit 変更をコミットします /compact トークン節約のため履歴メッセージを圧縮します /commitは自動で作成してコミットしてくれるので便利です。但し、git add、git pushは自身で行う必要があります。\nまとめ Copilot.luaと比較すると機能がかなり豊富になっていることがわかったかと思います。\nチャットモードによるファイル編集・ファイル作成、部分的な編集ができるとともに、MCPも利用することができるのでこのプラグインを上手に活用できればVS Codeに劣らずAIを用いたコーディングができるプラグインになっているかと思います。\n但し、難点としてチャットの回答が体感遅いのでこちらは我慢が必要です。(もしくは、copilotで試していたので他のモデルを利用することで改善するかもしれません。)\n","date":"2025-07-07T00:00:00Z","permalink":"http://192.168.122.81/p/neovim%E3%81%A7ai%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0-avante%E7%B7%A8/","title":"NeovimでAIコーディング (Avante編)"},{"content":"NeovimでCopilotを使いたい人向けのガイド(2025/7/5時点) 前回の記事で、NeovimのAIコーディング用プラグインを比較しました。今回はそのうちのCopilot.luaについてもう少し詳しく紹介しようと思います。\nNeovimのCopilotプラグインでできること 補完機能 利用している補完用プラグインとの連携も可能です。 Your browser doesn't support HTML5 video. Here is a link to the video instead. チャットモード (Askモードに相当する機能) 指定した行/ファイル/バッファに対してチャットでのやり取りが可能です。変更に対する差分の確認や反映もできます。 Your browser doesn't support HTML5 video. Here is a link to the video instead. また、便利な機能としてプロンプトを事前に用意しておくことができ、スラッシュコマンドで呼び出して利用することができます また、telescopeと連携することでエディターからプロンプトを直接呼び出すことも可能です。これは他のプラグインにはなかなかない機能で便利だと感じました。\nNeovimのCopilotプラグインでできないこと AIエージェントによるファイル作成や複数ファイルの編集 VSCodeのCopilotChatにおけるAgentモードに相当する機能は現状利用ができません\n設定方法 ここでは lazy.nvim を使った設定方法を記載しています。\nCopilot zbirenbaum/copilot.lua :Copilot auth で認証を行います。 1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;zbirenbaum/copilot.lua\u0026#34;, cmd = \u0026#34;Copilot\u0026#34;, event = \u0026#34;InsertEnter\u0026#34;, config = function() require(\u0026#34;copilot\u0026#34;).setup({ suggestion = { enabled = false }, panel = { enabled = false }, auto_trigger = false, }) end, }, copilot-cmp zbirenbaum/copilot-cmp 利用している補完用プラグインによって、必要な追加設定が異なります。\n詳細は こちら を参考にしてください。\n1 2 3 4 5 6 { \u0026#34;zbirenbaum/copilot-cmp\u0026#34;, config = function() require(\u0026#34;copilot_cmp\u0026#34;).setup({}) end, }, CopilotChat CopilotC-Nvim/CopilotChat.nvim 1 2 3 4 5 6 7 8 9 { \u0026#34;CopilotC-Nvim/CopilotChat.nvim\u0026#34;, branch = \u0026#34;main\u0026#34;, cmd = { \u0026#34;CopilotChat\u0026#34;, \u0026#34;CopilotChatOpen\u0026#34; }, build = \u0026#34;make tiktoken\u0026#34;, -- Only on MacOS or Linux config = function() require(\u0026#34;configs.copilot-chat\u0026#34;) end, }, CopilotChatで使えるプロンプトの接頭辞 CopilotChatでは、プロンプトでの接頭辞を活用できます。\n1. / — プリセット／スラッシュコマンド / に続けてコマンド名やプリセット名を書くと、あらかじめ用意された定型プロンプトを呼び出せます。\n例: /Explain → 選択中のコードの解説を依頼 例: /Tests → 単体テストを生成 例: /Fix → バグ修正提案 利用できるプリセットは環境や設定に応じて異なり、/ を入力すると候補がポップアップします。\n2. # — コンテキスト変数（Context） # に続けてコンテキスト名と必要に応じて入力を指定することで、チャットに「追加情報」を渡せます。以下のようなものがあります：\n#buffer … 現在のバッファ内容 #buffer:2 … バッファ番号 2 の内容 #files:*.js … ワークスペース内の *.js ファイル全体 #git:staged … ステージされた git diff #url:https://… … 指定 URL の内容取得 AI は必要に応じて「このコンテキストが欲しい」と提案してくることもあります。\n3. \u0026gt; — スティッキープロンプト（Sticky Prompt） Markdown の引用記法と同じく行頭に \u0026gt; を置くと、そのプロンプトは「スティッキー（常に貼り付け）」として保持され、新しいチャットを始めるたびに自動で先頭に挿入されます。\n例:\n1 2 \u0026gt; You are a helpful coding assistant. \u0026gt; Please respond concisely. とすると、どんな質問をしても毎回この指示が一番最初に送られます。\n設定ファイルでデフォルトのスティッキープロンプトを登録することも可能です。\nこれらを組み合わせることで、\n/Review #buffer のように「現在のバッファをレビューしてほしい」 事前に \u0026gt; markdown を貼って「以降の回答を Markdown 形式で」 …といった柔軟なチャット操作が可能になります。 まとめ AIの補完機能については、競合が少なくCopilot.luaが無難な選択肢になりそうです。\nまた、CopilotChatは機能としてはシンプルで、まだAIを使ったコーディングを行ったことがない方にとっては取り入れやすいプラグインかと思います。\n但し、Askモード相当の機能しかないため、がっつりコードを書く人にとっては機能的に物足りないプラグインという感想です。\nまだ開発も続いていそうなのでまた大きなアップデートが来たら記事にしてみたいと思います。\n","date":"2025-07-05T00:00:00Z","permalink":"http://192.168.122.81/p/neovim%E3%81%A7ai%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0-copilot%E7%B7%A8/","title":"NeovimでAIコーディング (Copilot編)"},{"content":"Neovim AIコーディング用プラグイン（2025/06/20） 他にも様々あるかと思いますが、コーディングのサポートがあり、GitHubのスター数が1k以上ということを基準に探してみました。\n🔍 比較対象プラグイン avante.nvim Copilot.vnim (+CopilotChat.nvim) codecompanion.nvim 📊 機能比較表 プラグイン名 GitHub Star 補完機能 チャットモード ファイル作成 複数ファイル同時編集 avante.nvim 14.9k × ◯ ◯ ✕ CopilotChat.nvim 3K(3.5k) ◯ ◯ ✕ codecompanion.nvim 4.4k × ◯ ✅ Slashで新規作成可 ✅ 複数チャット同時 ＆ ワークフロー可能 💡 詳細な解説 avante.nvim スター数：約1.3K ([github.com][1], [github.com][2], [neovim.discourse.group][3]) 補完機能：完全なインライン補完ではなく、チャットで差分を提案 → diff形式で即適用 チャットモード：あり。対話形式でdiff提案 ワークスペース読み込み：基本的には現在のファイルのみ ファイル作成：未対応 複数ファイル対応：diffは単一ファイル中心 CopilotChat.nvim スター数：約3K 補完機能：copilot.lua 経由でインライン補完 チャットモード：あり。チャットUI＋diff 組み込み ([github.com][4]) ワークスペース読み込み：Smart embedding によるバッファ/ファイル全体の読み込み ([github.com][4]) ファイル作成：難しいが Quickfix 連携で実質可能 複数ファイル対応：Quickfix／複数バッファ処理で対応 codecompanion.nvim スター数：約4.4K ([github.com][4]) 補完機能：インライン補完対応（複数LLM） チャットモード：あり。チャットバッファ、エージェント機能 ([github.com][5]) ワークスペース読み込み：バッファ、LSP、ツール／ワークフローにも対応 ファイル作成：Slash Commands 等で新規ファイル生成に対応 複数ファイル対応：複数チャット、エージェントで同時操作が可能 🧭 おすすめ用途ごとに選ぶなら？ diffで提案 → すぐ適用したい人：avante.nvim Copilot Chat を Neovim で使いたい人：CopilotChat.nvim フルスタックAI開発支援（補完〜ファイル生成〜複数ファイル編集）を目指す人：codecompanion.nvim ","date":"2025-06-20T00:00:00Z","permalink":"http://192.168.122.81/p/neovim%E3%81%A7%E4%BD%BF%E3%81%88%E3%82%8Bai%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E6%94%AF%E6%8F%B4%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E6%AF%94%E8%BC%832025%E5%B9%B4%E7%89%88/","title":"Neovimで使えるAIコーディング支援プラグイン比較【2025年版】"},{"content":"前回は仮想ネットワーク上にProxyサーバーを構築しました 今回はDNSサーバーを構築し、LANで名前解決ができるようにします\n1.構成と準備 2.Webサーバーの構築 3.Proxyサーバーの構築 4.DNSサーバーの構築 \u0026lt;- ここ 5.Grafanaで監視基盤の構築 ネットワーク構成のイメージ図 完成形\n今回の内容\n仮想マシンのデプロイ まずはDNSサーバー用の仮想マシンを作成していきます。 前回と同じ手順になるので作成や起動の手順は割愛します。 作成した仮想マシンの詳細は以下です\n名前: dns-server 管理ネットワーク側IP: 192.168.122.30 仮想ネットワーク側IP: 192.168.123.130 DNSサーバの構築 unboundを用いてDNSサーバーを構築します。 まずは、デプロイした仮想マシン上でunboundをインストールします\n1 $ sudo apt install unbound インストールが完了したら、設定を行っていきます。 設定ファイルは/etc/unbound/unbound.confにあり、以下のように記載されています。\n1 2 3 4 5 6 7 8 9 10 11 $ cat /etc/unbound/unbound.conf # Unbound configuration file for Debian. # # See the unbound.conf(5) man page. # # See /usr/share/doc/unbound/examples/unbound.conf for a commented # reference config file. # # The following line includes additional configuration files from the # /etc/unbound/unbound.conf.d directory. include-toplevel: \u0026#34;/etc/unbound/unbound.conf.d/*.conf\u0026#34; /etc/unbound/unbound.conf.d/*.confのファイルを読み込むように設定されているため、今回は/etc/unbound/unbound.conf.d/unbound.confとして設定ファイルを作成します\n設定ファイルには、server句とforward-zone句の二種類を記述し、以下のように記述することで設定が可能です。\n1 2 3 4 5 6 7 8 9 10 11 12 13 server: interface: DNSサーバーのIP port: 53 access-control: 127.0.0.0/8 allow access-control: LANのCIDR allow use-syslog: yes log-queries: yes local-data: \u0026#34;ドメイン. IN A 転送先のIP\u0026#34; forward-zone: name: \u0026#34;.\u0026#34; forward-addr: フォワード先のプライマリDNS forward-addr: フォワード先のセカンダリDNS server句\ninterface: Unboundが待ち受けるIPアドレスを指定 port: 使用するポート番号を指定 (DNSの標準ポートは53) access-control: DNSリクエストを許可するクライアントのIP範囲をCIDR形式で指定 use-syslog: ログ出力先をsyslogにするかどうかを指定。yes にすると /var/log/syslog に出力されます。 log-queries: DNSクエリをログに記録するかどうかの設定。設定しておくとトラブルシュートや監視に便利です。 local-data: 特定のホスト名とIPアドレスの対応を定義。(\u0026ldquo;myhost.local. IN A 192.168.1.10\u0026rdquo; とすると、myhost.localへの問い合わせには192.168.1.10を返します。) forward-zone句 name: . は「すべてのドメイン」を意味し、全てのDNSクエリをこのゾーンの設定に従って処理します。 forward-addr: クエリを転送する先のDNSサーバーを指定。複数指定可能で、上から順に試行されます。 その他の設定は以下期に記載されているので参考にしてください\nunbound.conf(5) | 日本Unboundユーザー会 今回の構成では、以下のように設定します。\n1 2 3 4 5 6 7 8 9 10 11 12 server: interface: 192.168.122.30 port: 53 access-control: 127.0.0.0/8 allow access-control: 192.168.122.0/24 allow use-syslog: yes log-queries: yes local-data: \u0026#34;memos.local. IN A 192.168.123.115\u0026#34; forward-zone: name: \u0026#34;.\u0026#34; forward-addr: 8.8.8.8 設定が完了したらunboundを再起動します\n1 $ sudo systemctl restart unbound.service 以上でDNSサーバー側の設定は完了です。 ここからは、構築したDNSサーバーを用いて名前解決ができるようにProxyサーバーへ設定を追加します\nProxyサーバーで使用するDNSサーバーの指定 Proxyサーバーにて、squidで使用するDNSサーバーの設定を行います 設定はすごく簡単で、/etc/squid/squid.confに以下のように設定を追加するだけです\n1 dns_nameservers DNSサーバーのIP dns_nameserversの設定について記載されている行があるので、こちらに追記します\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # TAG: dns_nameservers # Use this if you want to specify a list of DNS name servers # (IP addresses) to use instead of those given in your # /etc/resolv.conf file. # # On Windows platforms, if no value is specified here or in # the /etc/resolv.conf file, the list of DNS name servers are # taken from the Windows registry, both static and dynamic DHCP # configurations are supported. # # Example: dns_nameservers 10.0.0.1 192.172.0.4 #Default: # Use operating system definitions dns_nameservers 192.168.122.30 # ★追記 設定が完了したら、下記コマンドでsquidを再起動します。\n1 $ sudo systemctl restart squid それでは、構築したDNSサーバーで名前解決ができるか確認していきましょう 設定がうまく通っていれば、無事http://memos.local:5230でWebサーバーにアクセスできるようになっていると思います\nポート指定が不格好なので、Webサーバーのポートフォワードを変更します\n1 2 3 4 5 6 $ sudo docker stop memos memos $ sudo docker rm memos memos $ sudo docker run -d --init --name memos --publish 80:5230 --volume ~/.memos/:/var/opt/memos neosmemo/memos:stable bba4c0f06042e102eb7ffa0cd620f8425d4deb26d0162f32b68cb33e4c7c0461 これでhttp://memos.localだけでアクセスができるようになりました\n補足:ログの確認方法 Proxyサーバー (squid) squidのログはaccess.logから確認ができます\n1 2 3 4 5 6 7 8 9 10 11 ubuntu@ubuntu:~$ sudo tail /var/log/squid/access.log 1743953619.583 3 192.168.122.125 TCP_MISS/200 531 POST http://memos.local/memos.api.v1.WorkspaceSettingService/GetWorkspaceSetting - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.609 2 192.168.122.125 TCP_MISS/200 605 POST http://memos.local/memos.api.v1.WorkspaceSettingService/GetWorkspaceSetting - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.617 3 192.168.122.125 TCP_MISS/200 550 POST http://memos.local/memos.api.v1.AuthService/GetAuthStatus - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.625 2 192.168.122.125 TCP_MISS/200 526 POST http://memos.local/memos.api.v1.UserService/GetUserSetting - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.715 3 192.168.122.125 TCP_MISS/200 510 POST http://memos.local/memos.api.v1.UserService/ListShortcuts - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.715 5 192.168.122.125 TCP_MISS/200 510 POST http://memos.local/memos.api.v1.InboxService/ListInboxes - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.718 5 192.168.122.125 TCP_MISS/200 941 POST http://memos.local/memos.api.v1.MemoService/ListMemos - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953619.747 2 192.168.122.125 TCP_MISS/200 25371 GET http://memos.local/full-logo.webp - HIER_DIRECT/192.168.123.115 image/webp 1743953620.078 3 192.168.122.125 TCP_MISS/200 526 POST http://memos.local/memos.api.v1.UserService/GetUserStats - HIER_DIRECT/192.168.123.115 application/grpc-web+proto 1743953690.354 5007 192.168.122.125 TCP_TUNNEL/503 0 CONNECT push.services.mozilla.com:443 - HIER_NONE/- - DNSサーバー (unbound) unboundのログは/var/log/syslogに保存されます。\n1 2 3 4 5 6 7 8 9 10 ubuntu@ubuntu:~$ sudo tail /var/log/syslog | grep unbound 2025-04-06T15:33:28.423362+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 www.google.com. AAAA IN 2025-04-06T15:34:45.402548+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. A IN 2025-04-06T15:34:45.403307+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. AAAA IN 2025-04-06T15:34:50.404939+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. A IN 2025-04-06T15:34:50.406916+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. AAAA IN 2025-04-06T15:34:50.407588+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. A IN 2025-04-06T15:34:50.408005+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. AAAA IN 2025-04-06T15:34:50.408470+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. A IN 2025-04-06T15:34:50.408629+00:00 ubuntu unbound: [2930:0] info: 192.168.122.83 push.services.mozilla.com. AAAA IN ","date":"2025-04-05T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%A7%E8%87%AA%E5%AE%85%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%894.dns%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E6%A7%8B%E7%AF%89/","title":"【KVMで自宅インフラ構築】4.DNSサーバーの構築"},{"content":"前回は仮想ネットワーク上にWebサーバーを構築しました 今回はProxyサーバーを構築し、管理ネットワークからWebサーバーを閲覧できるようにします\n1.構成と準備 2.Webサーバーの構築 3.Proxyサーバーの構築 \u0026lt;- ここ 4.DNSサーバーの構築 5.Grafanaで監視基盤の構築 ネットワーク構成のイメージ図 完成形\n今回の内容\n仮想マシンのデプロイ まずはProxyサーバー用の仮想マシンを作成していきます。 前回と同じ手順になるので作成や起動の手順は割愛します。(proxy-serverの名前で仮想マシンを作成しました) つづいて、仮想マシンの仮想ネットワーク設定を行っていきます。 ProxyサーバーはWebサーバーを閲覧するPCが利用する管理ネットワークと、Webサーバーが接続される仮想ネットワークの両方に足を出している必要があります。 仮想ネットワークにはクローン時点で既に接続されているため、新しくネットワークインターフェースを作成し、管理ネットワークに接続します。 まずは仮想マシンのネットワークインターフェースからネットワークインターフェースの追加をクリックします 下記設定で追加します (仮想マシンがパワーオフの状態で実施する)\nインターフェース形式: Direct attachment ソース: enp1s0 (KVMホストの物理NICを指定します) モデル: virtio MACアドレス: 自動生成 永続: ☑常に割り当てる 追加が完了すると、Cockpitの画面で追加されていることが確認できます\nインターフェースが追加できたので、仮想マシンの方でもネットワークの設定をしてあげます\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ sudo cat /etc/netplan/50-cloud-init.yaml # This file is generated from information provided by the datasource. Changes # to it will not persist across an instance reboot. To disable cloud-init\u0026#39;s # network configuration capabilities, write a file # /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the following: # network: {config: disabled} network: ethernets: enp0s3: dhcp4: true dhcp-identifier: mac enp0s7: dhcp4: true version: 2 $ sudo netplan apply これで管理ネットワークと仮想ネットワークの両方に接続された仮想マシンが作成できました\n管理ネットワーク側IP: 192.168.122.83 仮想ネットワーク側IP: 192.168.123.120 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ ip a show enp0s7 3: enp0s7: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 52:54:00:87:91:ff brd ff:ff:ff:ff:ff:ff inet 192.168.122.83/24 metric 100 brd 192.168.122.255 scope global dynamic enp0s7 valid_lft 3465sec preferred_lft 3465sec inet6 fe80::5054:ff:fe87:91ff/64 scope link valid_lft forever preferred_lft forever $ ip a show enp0s3 2: enp0s3: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 52:54:00:54:18:43 brd ff:ff:ff:ff:ff:ff inet 192.168.123.120/24 metric 100 brd 192.168.123.255 scope global dynamic enp0s3 valid_lft 3468sec preferred_lft 3468sec inet6 fe80::5054:ff:fe54:1843/64 scope link valid_lft forever preferred_lft forever Proxyサーバの構築 squidを用いてProxyサーバーを構築します。 まずは、デプロイした仮想マシン上でsquidをインストールします\n1 $ sudo apt install squid インストールが完了したら、設定を行っていきます。 設定ファイルは/etc/squid/squid.confにあります。\n1 $ sudo vi /etc/squid/squid.conf ファイルの1400行目あたりに下記のような記載があるので、Allow_Local_Networkの設定を追記します\n1 2 3 4 5 6 7 8 9 10 11 12 # Example rule allowing access from your local networks. # Adapt to list your (internal) IP networks from where browsing # should be allowed acl localnet src 0.0.0.1-0.255.255.255 # RFC 1122 \u0026#34;this\u0026#34; network (LAN) acl localnet src 10.0.0.0/8 # RFC 1918 local private network (LAN) acl localnet src 100.64.0.0/10 # RFC 6598 shared address space (CGN) acl localnet src 169.254.0.0/16 # RFC 3927 link-local (directly plugged) machines acl localnet src 172.16.0.0/12 # RFC 1918 local private network (LAN) acl localnet src 192.168.0.0/16 # RFC 1918 local private network (LAN) acl localnet src fc00::/7 # RFC 4193 local private network range acl localnet src fe80::/10 # RFC 4291 link-local (directly plugged) machines acl Allow_Local_Network src 192.168.123.0/24 # \u0026lt;- ★ この行を追記 さらに、1601行目あたりの下記コメントがある行に二行追記します\n1 2 3 4 5 # For example, to allow access from your local networks, you may uncomment the # following rule (and/or add rules that match your definition of \u0026#34;local\u0026#34;): # http_access allow localnet http_access allow localnet http_access allow Allow_Local_Network 上記設定が完了したら、下記コマンドでsquidを再起動します。\n1 $ sudo systemctl restart squid Proxyサーバーを経由したWebサーバーへのアクセス Proxyサーバーの構築が完了したので、これを利用してWebサーバーへのアクセスを行います。 そのためには、WebサーバーへアクセスするクライアントにてProxyサーバーを利用する設定を行う必要があります。 今回はUbuntuサーバーを用いるため、以下の手順でProxyサーバーの設定を行います\n「Settings」→「Network」→「Proxy」 「Network Proxy」を有効にし、以下設定を入力する Configuration: Manual HTTP Proxy: URL: Proxyサーバーの管理用ネットワーク側のIP (192.168.122.83) Port: ProxyサーバーのPort (3128) HTTPS Proxy: URL: Proxyサーバーの管理用ネットワーク側のIP (192.168.122.83) Port: ProxyサーバーのPort (3128) 上記設定が完了したら、ブラウザでWebサーバーにアクセスができるようになります！(http://192.168.123.15:5230)\n以上でsquidを用いたProxyサーバーの構築ができました。 次は4.DNSサーバーの構築でLAでN名前解決ができるようにします\n","date":"2025-03-14T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%A7%E8%87%AA%E5%AE%85%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%893.proxy%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E6%A7%8B%E7%AF%89/","title":"【KVMで自宅インフラ構築】3.Proxyサーバーの構築"},{"content":"前回はこれから作成する環境の構築の紹介とその準備を行いました。 今回はOSSを用いて簡単なWebサーバーを構築します\n1.構成と準備 2.Webサーバーの構築 \u0026lt;-ここ 3.Proxyサーバーの構築 4.DNSサーバーの構築 5.Grafanaで監視基盤の構築 ネットワーク構成のイメージ図 完成形\n今回の内容\nWebサーバーに利用するOSS選び このシリーズの目的としてはWebサーバーにこだわる必要はないのですが。。 せっかくなのでおすすめのOSSをいくつか紹介します\nmemos シンプルで軽量な自己ホスト型のメモ管理アプリ マークダウンをサポート Slackのような使い心地のメモ帳 gitea 軽量な自己ホスト型Gitサービス GitHubのようなリポジトリ管理をローカル環境で実現できる 低リソースで動作するのが特徴 Mattermost オープンソースのチーム向けチャットプラットフォーム Slackの代替として利用でき、高いカスタマイズ性を持つ Nextcloud 自己ホスト型のクラウドストレージサービス DropboxやGoogle Driveの代替として利用できる ファイル共有やコラボレーション機能が充実 Immich オープンソースの自己ホスト型写真・動画管理システム Google Photosの代替として利用できる AIによる画像認識や自動バックアップ機能をもつ 今回はmemosを使ってWebサーバーを構築します\n仮想マシンのデプロイ それではWebサーバー用の仮想マシンを作成していきます。 まずは仮想マシンの準備で作成した仮想マシンをクローンして新しい仮想マシンを作成します\n作成が完了したら、仮想マシンが仮想ネットワークdefaultに接続されていることを確認します\nネットワークの確認ができたら実行をクリックして仮想マシンを起動します\n起動が完了したら仮想マシンの画面からコンソールに入ることができます (SSHでログインしたい場合は KVMホスト -\u0026gt; 作成した仮想マシンで接続してください)\nWebサーバーの起動 デプロイは公式ドキュメントに沿ってDockerを使って行います。 下記dockerコマンドを実行するだけで完了です\n1 2 3 4 5 6 sudo docker run -d \\ --init \\ --name memos \\ --publish 5230:5230 \\ --volume ~/.memos/:/var/opt/memos \\ neosmemo/memos:stable まだブラウザから確認ができないため、curlコマンドでWebサーバーが動作しているか確認します\n1 2 3 4 5 6 $ curl -I 0.0.0.0:5230 HTTP/1.1 200 OK Accept-Ranges: bytes Content-Length: 2784 Content-Type: text/html; charset=utf-8 Date: Thu, 20 Mar 2025 14:20:13 GMT~$ curl -I 0.0.0.0:5230 確認できました。これでWebサーバーの準備は完了です！ 次は3.Proxyサーバーの構築でProxy経由でWebサーバーにアクセスできるようにします\n","date":"2025-03-12T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%A7%E8%87%AA%E5%AE%85%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%892.web%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E6%A7%8B%E7%AF%89/","title":"【KVMで自宅インフラ構築】2.Webサーバーの構築"},{"content":"自宅でKVMを使ったシンプルなインフラ環境を構築します Proxyサーバーを介してWebサーバーへ接続し、さらにDNSで名前解決をできるようにします 最終的にgrafanaで各サーバーの監視設定を行うところまでをやろうと思います\n構築の流れ 1.構成と準備 \u0026lt;-ここ 2.Webサーバーの構築 3.Proxyサーバーの構築 4.DNSサーバーの構築 5.Grafanaで監視基盤の構築 ネットワーク構成のイメージ図 扱うネットワークは以下の２つです\n管理用ネットワーク: 192.168.122.0/24 Webサーバーを利用するクライアントが接続されているネットワーク このネットワークからProxyを介してWebサーバーにアクセスします KVMの仮想ネットワーク: 192.168.123.0/24 Webサーバーが接続されるローカルネットワーク 利用するソフトウェア 仮想マシンの作成やネットワークの設定にはCockpitを使用します\nKVMホストの構成 本シリーズ用に物理のホストを用意できなかったため、Nested KVM構成で行います\nCPU: 4vCPU メモリ: 16GB ストレージ: 100GB OS: Ubuntu 24.04 ネットワーク構成 仮想ネットワークには、デフォルトで作成されるdefaultを使用します\n1 2 3 4 $ virsh net-list Name State Autostart Persistent -------------------------------------------- default active yes yes この仮想ネットワークの詳細はnet-dumpxmlで確認することができ、以下の通りです\nNATモード で動作し、仮想マシンが外部ネットワークへアクセス可能 仮想ブリッジvirbr0を使用して通信を管理 ホストのIP (192.168.123.1) がゲートウェイとして機能 DHCP により、 192.168.123.2 〜 192.168.123.254 の範囲でIPアドレスを自動割り当て 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ virsh net-dumpxml default \u0026lt;network\u0026gt; \u0026lt;name\u0026gt;default\u0026lt;/name\u0026gt; \u0026lt;uuid\u0026gt;61c20183-757b-402f-a92e-677072b910d0\u0026lt;/uuid\u0026gt; \u0026lt;forward mode=\u0026#39;nat\u0026#39;\u0026gt; \u0026lt;nat\u0026gt; \u0026lt;port start=\u0026#39;1024\u0026#39; end=\u0026#39;65535\u0026#39;/\u0026gt; \u0026lt;/nat\u0026gt; \u0026lt;/forward\u0026gt; \u0026lt;bridge name=\u0026#39;virbr0\u0026#39; stp=\u0026#39;on\u0026#39; delay=\u0026#39;0\u0026#39;/\u0026gt; \u0026lt;mac address=\u0026#39;52:54:00:a3:31:ff\u0026#39;/\u0026gt; \u0026lt;ip address=\u0026#39;192.168.123.1\u0026#39; netmask=\u0026#39;255.255.255.0\u0026#39;\u0026gt; \u0026lt;dhcp\u0026gt; \u0026lt;range start=\u0026#39;192.168.123.2\u0026#39; end=\u0026#39;192.168.123.254\u0026#39;/\u0026gt; \u0026lt;/dhcp\u0026gt; \u0026lt;/ip\u0026gt; \u0026lt;/network\u0026gt; 仮想マシンの準備 今回は合計で4つの仮想マシンを構築します。 都度一から作成するのは面倒なのでテンプレートを作成し、それをクローンする形で使用します スペックは以下の通りです。\nCPU: 2vCPU メモリ: 4GB ストレージ: 20GB OS: Ubuntu 24.04 また、クローンした仮想マシンにDHCPから異なるIPが割り当てるよう、以下設定を追記しておきます (参考)\n1 2 3 4 5 6 network: ethernets: enp1s0: dhcp4: true dhcp-identifier: mac # この行を追記 version: 2 これで準備が整いました。次回は2.Webサーバーの構築を進めていきます\n","date":"2025-03-10T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%A7%E8%87%AA%E5%AE%85%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E6%A7%8B%E7%AF%891.%E6%A7%8B%E6%88%90%E3%81%A8%E6%BA%96%E5%82%99/","title":"【KVMで自宅インフラ構築】1.構成と準備"},{"content":"前回はcockpitでWebブラウザからVMを確認するところまでを実施しました。今回はcockpitからVMを構築してみようと思います。\nネットワークの作成 前回作成したubuntu001は、デフォルトで作成されていたネットワーク(default)にアタッチしました。\n今回は新しくネットワークを作成し、そこにアタッチする形にしようと思います\ncockpitの仮想マシンタブから1個のネットワークをクリックします\n上の画像のようにdefaultネットワークの情報が確認できました\n仮想ネットワークの作成よりネットワークを作成します\n設定は以下を入力し、作成ボタンをクリックします\n名前: test_network001 フォワードモード: NAT (NATを使用してグローバルに出ることができる設定) デバイス: virbr0 (virbr0を設定しておくと新規でブリッジvirbr1が作成され、利用されます) IP設定: IPv4のみ IPv4 アドレス: 192.168.100.1 マスクまたはプレフィックス長: 24 DHCPの範囲を設定します: ☑ 開始: 192.168.100.2 / 末尾: 192.168.100.254 新しくtest_network001のネットワークが作成されたことが確認できます\nまた、デバイスにvirbr0を指定して作成しましたが、自動的に新しいブリッジvirbt1が作成され、デバイスに指定されていることが確認できます\n有効化をクリックすることで、このネットワークが利用可能になります。ホスト起動時に自動的に起動されるよう自動起動を有効にしておきましょう\nVMの構築 それではいよいよ仮想マシンの作成をしてみようと思います\ncockpitの仮想マシンから、仮想マシンの作成をクリックします\n表示される作成画面に、以下情報を入力し、作成して実行するをクリックしましょう\n接続: System インストールタイプ: ローカルインストールメディア インストールソース: /iso/ubuntu-24.04.1-live-server-amd64.iso オペレーティングシステム: Ubuntu 24.04 LTS (Noble Numbat) ストレージ: qcow2ボリュームの新規作成 ストレージの制限: 20GB メモリ: 4GB 作成してまもなく仮想マシンの一覧に追加され、状態が Runnningになっていることが確認できます\n作成したubuntu002を開いてみると、VMの情報と共に画面右側のコンソールではUbuntuのインストールが始まっていることが確認できます\nディスクとネットワークの設定は以下図のようになっています。\nディスクはメインで使用するdiskと、OSをインストールするためのcdromがアタッチされています\nネットワークをみるとdefaultのネットワークがアタッチされていることがわかります。新しく作成したネットワークにしたいので、変更をしてみましょう\nネットワークの編集ボタンをクリックし、開かれる画面からソースをtest_network001に変更します\nこれにより、インターフェースのソースとIPが変更されていることが確認できます\n以上がcockpitからのVM作成の手順になります。virshを用いた方法と比較してかなり簡単に作成できることがわかります\nVMの構築②(番外編) 前の章では、cockpitで一から仮想マシンを作成しましたが、既存のVMをコピーすることで更に簡単にVMを作成することができます\n以下手順でVMのコピーを実施します\nコピー元の仮想マシンをシャットダウンする コピー元仮想マシンの右側三点リーダーからクローンを選択 名前を入力してクローンをクリック 終わりです。コピー元VMからコピーして新しいVMが作成されました\n以上、cockpitを使って仮想マシンを作成する方法を紹介しました。\n次回は仮想マシンがアタッチされる、仮想ネットワークについて書いていこうと思います\n","date":"2024-12-17T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%AE%E4%BB%AE%E6%83%B3%E5%8C%96%E5%85%A5%E9%96%80cockpit%E3%81%A7vm%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/","title":"【KVMの仮想化入門④】cockpitでVMを構築してみる"},{"content":"前回はvirshを使って、CLIからVMを構築しました。今回はVMをブラウザから操作するためのcockpitをインストールして動かして見ようと思います\ncockpitとは: cockpitとは、下記特徴を持つソフトウェアです。今回は仮想化のために使用しますが、それはあくまでcockpitの機能の一部を利用する形となります\nLinuxシステムのサーバ管理用webサーバー LinuxシステムのCPU、メモリ、ネットワーク、ストレージなどのシステムリソースの使用状況をリアルタイムで監視できる 仮想マシンの作成、起動、停止、スナップショットの作成等簡単な操作をGUIで行うことができる 小規模な環境やシンプルな仮想化運用に適している その他のソフトウェアも気になっているので、後々記事にしていければと思っています\n以下は、LinuxにCockpitをインストールして仮想マシンを確認する手順を紹介するブログのMarkdown形式のサンプルです。\ncockpitのインストールと起動 以下のコマンドを実行して、cockpitと仮想マシンの管理に必要なパッケージをインストールします。\n1 sudo apt install cockpit cockpit-machines インストールが完了したら、Cockpitサービスを開始します。\n1 sudo systemctl start cockpit cockpit Webインターフェースにアクセス cockpitの起動が完了したため、Webブラウザから9090ポートで管理画面にアクセスできます。\n1 https://\u0026lt;サーバーのIPアドレス\u0026gt;:9090 以下のようなログインページが表示されるため、ubuntuのログインユーザーでログインします\nログインすると以下のような画面になります\nそして、仮想マシンのタブを開くと既に作成しているubuntu001が確認でき、\nこのページからは仮想マシンに対して以下の操作が可能となっています\nVMのインポート/新規作成 VMの電源操作(起動、停止、再起動) VMの移行 VMの削除 また、VM名をクリックすることでその仮想マシンの詳細を確認することができます\nここからVMのコンソールを操作することができるため、ここで作成したubuntu001のセットアップを行ないます\n(この記事では本手順は省略します。わからない方はこちらを参考にしていただけると良いかもしれません。)\n","date":"2024-12-16T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%AE%E4%BB%AE%E6%83%B3%E5%8C%96%E5%85%A5%E9%96%80cockpit%E3%81%A7%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%8B%E3%82%89vm%E3%82%92%E6%93%8D%E4%BD%9C%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/","title":"【KVMの仮想化入門③】cockpitでブラウザからVMを操作してみる"},{"content":"前回はKVMの仮想化基盤を用意するところまでをやってみました。今回はvirshを用いてCLIから仮想マシンを構築するところまでをやってみます\nvirshとは KVMやQEMUを利用した仮想化基盤の管理をコマンドラインから行うためのツール Libvirtという仮想化管理ツールをバックエンドに利用 仮想マシンの作成、削除、起動、停止、リソースの管理などをシンプルなコマンドで実行可能 virshで利用できる参照コマンド virshには仮想化リソースを参照するための多くのコマンドが用意されています。\nまずはよく利用しそうなコマンドを使ってみようと思います\n仮想マシンの参照コマンド virsh list --all 稼働中、停止中を問わずすべてのVMを表示します(今回はまだVMを作成できていないので表示なし) 1 2 3 ubuntu@kvm001:~$ virsh list --all Id Name State -------------------- 仮にVMが存在した場合、以下のような表示になります\n1 2 3 4 5 $ virsh list --all Id Name State -------------------------------- 12 ubuntu001 running - ubuntu002 shut off virsh dominfo \u0026lt;VM名\u0026gt; 指定したVMの詳細情報を表示(別途用意した環境で確認) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ virsh dominfo ubuntu001 Id: 12 Name: ubuntu001 UUID: bdce429c-1284-463b-8af4-f538374a3b2d OS Type: hvm State: running CPU(s): 2 CPU time: 10368.9s Max memory: 3145728 KiB Used memory: 3145728 KiB Persistent: yes Autostart: disable Managed save: no Security model: none Security DOI: 0 Messages: tainted: running with undesirable elevated privileges 仮想ネットワークの参照コマンド virsh net-list 現在有効な仮想ネットワークの一覧を表示します。 default という名前の仮想ネットワークがすでに作成されていることがわかります 1 2 3 4 ubuntu@kvm001:~$ virsh net-list --all Name State Autostart Persistent -------------------------------------------- default active yes yes virsh net-dumpxml \u0026lt;ネットワーク名\u0026gt; 指定したネットワークの設定を表示します。 1 2 3 4 5 6 7 ubuntu@kvm001:~$ virsh net-info default Name: default UUID: 61c20183-757b-402f-a92e-677072b910d0 Active: yes Persistent: yes Autostart: yes Bridge: virbr0 この仮想ネットワークについては、今後もう少し詳細を書きたいと思っています\n仮想ストレージの参照コマンド virsh pool-list 現在利用可能なストレージプールの一覧を表示します。(今回はまだ作成できていないので表示なし) 1 2 3 ubuntu@kvm001:~$ virsh pool-list --all Name State Autostart --------------------------- すでに作成されていた場合、以下のような表示になります\n1 2 3 4 5 $ virsh pool-list Name State Autostart ------------------------------------ default active yes ubuntu active yes virsh pool-info \u0026lt;プール名\u0026gt; 指定したストレージプールの詳細情報を表示します。 1 2 3 4 5 6 7 8 9 $ virsh pool-info default Name: default UUID: fa63badf-324b-4fa9-992c-81581e9c307f State: running Persistent: yes Autostart: yes Capacity: 456.35 GiB Allocation: 72.34 GiB Available: 384.00 GiB virsh仮想マシンを構築する 前置きが長くなりましたが、いよいよ仮想マシンの構築に入ります。\nisoの準備 今回は、ubuntuのVMを作成しようと思うので、wgetでubuntuのisoをダウンロードしておきます\n1 2 mkdir /iso sudo wget -P /iso https://releases.ubuntu.com/24.04.1/ubuntu-24.04.1-live-server-amd64.iso ディスクイメージの準備 仮想マシン用のディスクイメージを作成します。\n1 sudo qemu-img create -f qcow2 /var/lib/libvirt/images/ubuntu001.qcow2 20G 仮想マシンのXMLファイルを作成 libvirtでは、XMLを用いてVMの構成管理が行われます\nそのため、以下の仮想マシンの構成を定義するXMLファイルを用意します\n1 vi ubuntu001.xml ファイルには以下内容を記載します\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;domain type=\u0026#39;kvm\u0026#39;\u0026gt; \u0026lt;name\u0026gt;ubuntu001\u0026lt;/name\u0026gt; \u0026lt;memory unit=\u0026#39;MiB\u0026#39;\u0026gt;4096\u0026lt;/memory\u0026gt; \u0026lt;vcpu placement=\u0026#39;static\u0026#39;\u0026gt;2\u0026lt;/vcpu\u0026gt; \u0026lt;os\u0026gt; \u0026lt;type arch=\u0026#39;x86_64\u0026#39; machine=\u0026#39;pc-i440fx-6.2\u0026#39;\u0026gt;hvm\u0026lt;/type\u0026gt; \u0026lt;boot dev=\u0026#39;cdrom\u0026#39;/\u0026gt; \u0026lt;/os\u0026gt; \u0026lt;devices\u0026gt; \u0026lt;disk type=\u0026#39;file\u0026#39; device=\u0026#39;disk\u0026#39;\u0026gt; \u0026lt;driver name=\u0026#39;qemu\u0026#39; type=\u0026#39;qcow2\u0026#39;/\u0026gt; \u0026lt;source file=\u0026#39;/var/lib/libvirt/images/ubuntu001.qcow2\u0026#39;/\u0026gt; \u0026lt;target dev=\u0026#39;vda\u0026#39; bus=\u0026#39;virtio\u0026#39;/\u0026gt; \u0026lt;/disk\u0026gt; \u0026lt;disk type=\u0026#39;file\u0026#39; device=\u0026#39;cdrom\u0026#39;\u0026gt; \u0026lt;driver name=\u0026#39;qemu\u0026#39; type=\u0026#39;raw\u0026#39;/\u0026gt; \u0026lt;source file=\u0026#39;/iso/ubuntu-24.04.1-live-server-amd64.iso\u0026#39;/\u0026gt; \u0026lt;target dev=\u0026#39;sda\u0026#39; bus=\u0026#39;sata\u0026#39;/\u0026gt; \u0026lt;/disk\u0026gt; \u0026lt;interface type=\u0026#39;network\u0026#39;\u0026gt; \u0026lt;source network=\u0026#39;default\u0026#39;/\u0026gt; \u0026lt;/interface\u0026gt; \u0026lt;graphics type=\u0026#39;vnc\u0026#39; port=\u0026#39;-1\u0026#39; autoport=\u0026#39;yes\u0026#39;/\u0026gt; \u0026lt;/devices\u0026gt; \u0026lt;/domain\u0026gt; XMLに記載している内容について、細かい内容は省略しますが下記設定を盛り込んでいます\n基本情報 \u0026lt;name\u0026gt;ubuntu001\u0026lt;/name\u0026gt;: vm名をubuntu001とする \u0026lt;memory unit='MiB'\u0026gt;4096\u0026lt;/memory\u0026gt;: 仮想マシンに割り当てるメモリ量を4096MB=2GBとする \u0026lt;vcpu placement='static'\u0026gt;2\u0026lt;/vcpu\u0026gt;: 割り当てるvCPUの数を2にする OSの設定 (\u0026lt;os\u0026gt;) \u0026lt;boot dev='cdrom'/\u0026gt;: 仮想マシン起動時にCD-ROMを最初のブートデバイスとして使用するように設定 ストレージの設定 (\u0026lt;disk\u0026gt;) 仮想ディスク \u0026lt;source file='/var/lib/libvirt/images/ubuntu001.qcow2'/\u0026gt;: 作成した仮想ディスクのパスを指定 ISOイメージ（\u0026lt;disk\u0026gt;） \u0026lt;disk type='file' device='cdrom'\u0026gt;: ISOイメージを光学ドライブに割り当てる設定 \u0026lt;source file='/iso/ubuntu-24.04.1-live-server-amd64.iso'/\u0026gt;: ダウンロードしたISOイメージをソースに設定 ネットワーク設定 (\u0026lt;interface\u0026gt;) \u0026lt;interface type='network'\u0026gt;: 仮想マシンのネットワークインターフェイスを設定 (NATを用いた接続) \u0026lt;source network='default'/\u0026gt;: 事前定義されたdefaultネットワークを使用 詳細は下記サイトにまとまっています\n7.3. 仮想マシンの XML 設定例 | Red Hat Product Documentation 仮想マシンの定義を読み込む 用意したXMLファイルを読み込み、仮想マシンを定義します。\n1 virsh define ubuntu001.xml ちなみに、この時点で仮想マシンが作成された状態となり、virsh list --allでその状態が確認できます。\n1 2 3 4 ubuntu@kvm001:~$ virsh list --all Id Name State ---------------------------- - ubuntu001 shut off 仮想マシンを起動 定義した仮想マシンを起動します。\n1 virsh start ubuntu001 起動後、以下のコマンドで仮想マシンの状態を確認します。\n1 2 3 4 ubuntu@kvm001:~$ virsh list --all Id Name State ---------------------- 3 myvm running 以上で仮想マシンを構築するところまでが完了しました。\n次回はcockpitを使ってwebのGUIからVMを操作するところまでを実施します\n","date":"2024-12-11T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%AE%E4%BB%AE%E6%83%B3%E5%8C%96%E5%85%A5%E9%96%80virsh%E3%81%A7vm%E3%82%92%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%97%E3%81%A6%E3%81%BF%E3%82%8B/","title":"【KVMの仮想化入門②】virshでVMをデプロイしてみる"},{"content":"KVM（Kernel-based Virtual Machine）について、少し勉強した上でLinuxのマシンにKVMの仮想化基盤を構築するところまでをやってみます\n仮想化の概要 KVMについてお話する前に、前提として仮想化と、そのプラットフォームについて書いてみます。\n仮想化とは、1つの物理コンピュータ上で複数の仮想マシン（Virtual Machine, VM）を実行する技術です。仮想化により、物理リソースの効率的な活用、アプリケーションの分離、テスト環境の作成が容易になります。\nKVMについて 仮想化技術に使用されるハイパーバイザには様々なものがありますが、今回利用するKVMについてざっくりと特徴を上げると以下になります\nオープンソースとして無料で提供されている Linuxカーネルに統合された仮想化機能 qemu, libvirtと組み合わせて利用される virsh, virt-manager, cockpit, OpenStack, oVirtなど様々な管理ツールが存在する AWS, GCP等のメガクラウドでも採用されている技術である ※ qemuについて: 第2回　Linux KVMで知る仮想マシンの概要 | gihyo.jp\n※ KVM管理ツールについて: KVMとは | OSSのデージーネット\nKVMを用いた仮想化環境の構築 以下コマンドで、必要なパッケージをインストールしていきます\n1 2 3 4 5 6 # 必要なパッケージのインストール sudo apt update sudo apt install -y qemu-kvm libvirt-daemon libvirt-clients bridge-utils # 再起動 sudo reboot すごく簡単ですが、インストールしているパッケージに関しての説明は以下です\nqemu-kvm KVM（仮想化）の中核となるパッケージ。必須。 libvirt-daemon 仮想マシンを管理するためのバックエンドサービス。必須。 libvirt-clients 仮想マシン管理用のCLIツール群。CLIから仮想マシンを操作する際に必要。 bridge-utils ブリッジネットワークの構築に使うツール群。仮想マシンをホストのブリッジネットワークに接続したい際に必要。 インストールの確認 以下のコマンドでインストールが成功しているか確認します。\nKVMの状態確認 1 2 3 ubuntu@kvm001:~$ sudo kvm-ok INFO: /dev/kvm exists KVM acceleration can be used libvirtサービスの状態確認 1 2 3 4 5 ubuntu@kvm001:~$ sudo systemctl status libvirtd ○ libvirtd.service - libvirt legacy monolithic daemon Loaded: loaded (/usr/lib/systemd/system/libvirtd.service; enabled; preset: enabled) Active: inactive (dead) since Fri 2024-12-13 03:18:37 UTC; 9s ago # ~~以下省略~~ 以上で、KVMとその関連ツールのインストールは完了です。\n次回はこのKVM環境でvirshを使って仮想マシンを構築してみます\n","date":"2024-12-10T00:00:00Z","permalink":"http://192.168.122.81/p/kvm%E3%81%AE%E4%BB%AE%E6%83%B3%E5%8C%96%E5%85%A5%E9%96%80-linux%E3%81%ABkvm%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B/","title":"【KVMの仮想化入門① 】LinuxにKVMをインストールする"}]